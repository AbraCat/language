В данной работе реализован высокоуровневый язык программирования. Единственным его типом данных является int. Он может компилироваться под эмулятор процессор или под x86-64. Эмулятор можно найти в репозитории https://github.com/AbraCat/virtual-processor. Проект состоит из фронтенда, мидленда, и двух бэкендов.

# Фронтенд

Переводит код на языке в промежуточное представление в виде дерева. Первой его частью является токенизатор, переводящий текстовый файл в массив узлов дерева. Каждый узел имеет один из 4 типов - число, переменная, функция, оператор. При совпадении очередного имени с именем оператора в узел записывается оператор. При встрече числа записывается число. Иначе новое имя заносится в массив имён, узлу присуждается тип переменной, в узел сохраняется номер имени.

Фронтенд соединяет узлы, полученные при токенизации, в дерево, с помощью алгоритма рекурсивного спуска. Программа состоит из определений функций. Функции могут принимать аргументы и имеют тело, состоящее из утверждений (statement). Statement может быть одним из:
* Объявление локальной переменной
* Присваивание
* Возврат из функции
* Оператор if/while
* Выражение

При встрече объявления переменной имя помечается объявленным и в узел записывается номер локальной переменной. При встрече переменной в присваивании или выражении проверяется, что используемая переменная объявлена. Операторы if/while имеют тело, похожее на тело функции, но они не могут содержать объявления переменных. Выражение является комбинацией арифметических операций и вызовов функций.

Также создан антифронтенд, преобразующий дерево в исходный код. При его использовании теряются имена переменных, т. к. фронтенд сохраняет вместо них номера. Антифронтенд нужен для кросс-компиляции с другими языками, использующими такой же формат дерева.

# Мидленд

Производит оптимизацию дерева, а именно сворачивает константные выражения в числа и убирает тривиальные операции, такие как сложение с 0 и умножение на 1.

# Бэкенд для эмулятора

Переводит дерево в ассемблерный код. В начале программы находится вызов функции main. Дальше находятся определения стандартных функций - input, output и sqrt. Перед вызовом функций в стек сохраняются адрес стекового фрейма и аргументы. После вызова функция вычисляет новый адрес фрейма. Локальные переменные, как и аргументы, находятся на стеке. Обращение к переменным и аргументам происходит через регистр фрейма с прибавлением номера переменной (аргументы и локальные переменные имеют общую нумерацию). Арифметические выражения компилируются в вычисления на стеке. If/while компилируются в набор прыжков. В конце работы функция освобождает фрейм и восстанавливает регистр фрейма. Возвращаемое значение передаётся через соответствующий регистр.

# Бэкенд для x86-64

Переводит дерево в исполняемый файл в формате ELF. Создаётся заголовок, в котором указываются характеристики программы, такие как микроархитектура, порядок байтов в числах и точка входа. Далее создаётся таблица сегментов. Весь файл кладётся в один сегмент с правами на чтение и исполнение. Далее записывается код стандартных функций ввода, вывода и завершения программы, написанных на ассемблере и заранее скомпилированных. Далее следует код самой программы. В отличие от бэкенда для эмулятора вычисления проводятся в регистрах, хотя стек тоже используется для хранения промежуточных значений. Используется адресация относительно rip, т. е. адреса в коде не зависят от расположения кода в памяти. 

# Benchmark

Проведено сравнение времени работы программы, скомпилированной под эмулятор процессора и под x86-64 с использованием разных бэкендов. Была написана функция, рекурсивно считающая факториал, и запущена 50 миллионов раз на входе 10. Время работы программы измерялось с помощью утилиты time. Тесты проводились по 5 раз, затем вычислялось среднее значение и стандартное отклонение. 

Код тестовой программы:

```
func recFactorial(n)
(
    if (n eq 0) (return 1),
    return recFactorial(n - 1) * n
),
func main()
(
    var nIters,
    var ans,
    nIters = 50000000,
    while (nIters neq 0)
    (
        ans = recFactorial(10),
        nIters = nIters - 1
    ),
    output(ans)
)
```

Результаты измерений:

| Бэкенд   | Время (с)       |
| -------- | --------------- |
| Эмулятор | 66.160 +- 0.458 |
| x86-64   |  1.178 +- 0.004 |

При компиляции под x86-64 программа оказалась в 56.163 +- 0.580 раз быстрее, чем при компиляции под эмулятор.
