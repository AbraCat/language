В данной работе реализован высокоуровневый язык программирования. Единственным его типом данных является int. Он компилируется в код на ассемблере для эмулятора процессора. Ассемблер и эмулятор можно найти в репозитории https://github.com/AbraCat/virtual-processor. Проект состоит из фронтенда, мидленда, и бэкенда.

# Фронтенд

Переводит код на языке в промежуточное представление в виде дерева. Первой его частью является токенизатор, переводящий текстовый файл в массив узлов дерева. Каждый узел имеет один из 4 типов - число, переменная, функция, оператор. При совпадении очредного имени с именем оператора в узел записывается оператор. При встрече числа записывается число. Иначе новое имя заносится в массив имён, узлу присуждается тип переменной, в узел сохраняется номер имени.

Фронтенд соединяет узлы, полученные при токенизации, в дерево, с помощью алгоритма рекурсивного спуска. Программа состоит из определений функций. Функции могут принимать аргументы и имеют тело, состоящее из утверждений (statement). Statement может быть одним из:
* Объявление локальной переменной
* Присваивание
* Возврат из функции
* Оператор if/while
* Выражение

При встрече объявления переменной имя помечается объявленным и в узел записывается номер локальной переменной. При встрече переменной в присваивании или выражении проверяется, что используемая переменная объявлена. Операторы if/while имеют тело, похожее на тело функции, но они не могут содержать объявления переменных. Выражение является комбинацией арифметических операций и вызовов функций.

Также создан антифронтенд, преобразующий дерево в исходный код. При его использовании теряются имена переменных, т. к. фронтенд сохраняет вместо них номера. Антифронтенд нужен для кросс-компиляции с другими языками, использующими такой же формат дерева.

# Мидленд

Производит оптимизацию дерева, а именно сворачивает константные выражения в числа и убирает тривиальные операции, такие как сложение с 0 и умножение на 1.

# Бэкенд

Переводит дерево в ассемблерный код. В начале программы находится вызов функции main. Дальше находятся опеределения стандартных функций - input, output и sqrt. Перед вызовом функций в стек сохраняются адрес стеквого фрейма и аргументы. После вызова функция вычисляет новый адрес фрейма. Локальные переменные, как и аргументы, находятся на стеке. Обращение к переменным и аргументам происходит через регистр фрейма с прибавлением номера переменной (аргументы и локальыне переменные имеют общую нумерацию). Арифметические выражения компилируются в вычисления на стеке. If/while компилируются в набор прыжков. В конце работы функция освобождает фрейм и восстанавливает регистр фрейма. Возвращаемое значение передаётся через соответствующий регистр.